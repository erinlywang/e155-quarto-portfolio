[
  {
    "objectID": "posts/week1-reflections.html",
    "href": "posts/week1-reflections.html",
    "title": "Week 1 Reflections",
    "section": "",
    "text": "This week I soldered all the components onto my development board, programmed LED0 to SW6 (S[1:0]) with an XOR gate, programmed LED1 to SW6 (S[3:2]) with an AND gate, programmed LED2 to blink at 2.4 Hz using the high frequency oscillator internal clock with a 24’bit counter, and programmed a 7-segment display to show a hexadecimal digit corresponding to SW6 (S[3:0])."
  },
  {
    "objectID": "posts/week1-reflections.html#summary",
    "href": "posts/week1-reflections.html#summary",
    "title": "Week 1 Reflections",
    "section": "",
    "text": "This week I soldered all the components onto my development board, programmed LED0 to SW6 (S[1:0]) with an XOR gate, programmed LED1 to SW6 (S[3:2]) with an AND gate, programmed LED2 to blink at 2.4 Hz using the high frequency oscillator internal clock with a 24’bit counter, and programmed a 7-segment display to show a hexadecimal digit corresponding to SW6 (S[3:0])."
  },
  {
    "objectID": "posts/week1-reflections.html#reflections-on-lab",
    "href": "posts/week1-reflections.html#reflections-on-lab",
    "title": "Week 1 Reflections",
    "section": "Reflections on Lab",
    "text": "Reflections on Lab\nThe lab was definitely difficult with learning how to use Radiant instead of Quartus Prime. I also found it tricky understanding how to program the blinking LED2 using the counter.\nI feel a lot more confident in understanding what is going on in a testbench program because before in E85 it seemed like somewhat of a black box to me.\nI’m still struggling with figuring out how to separate modules and writing testbenches for modules that don’t require a testvector file. I would like to continue strengthening my ability to write new modules and testbenches for those modules in a way that works in the overall top module. The trickiest module for this was trying to separate the clock divider for the blinking LED2 into another module. I ended up not doing a separate module because the code worked really well in the top module and I ran out of time.\nIf I have more time I would like to go back and retry making an led_blinker module that can have the HSOSC module outside of the led_blinker module and feed the internal clock int_osc into the blinking led module."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3 Report",
    "section": "",
    "text": "I spent 60 hours on this lab."
  },
  {
    "objectID": "labs/lab3/lab3.html#lab-hours",
    "href": "labs/lab3/lab3.html#lab-hours",
    "title": "Lab 3 Report",
    "section": "",
    "text": "I spent 60 hours on this lab."
  },
  {
    "objectID": "labs/lab3/lab3.html#introduction",
    "href": "labs/lab3/lab3.html#introduction",
    "title": "Lab 3 Report",
    "section": "Introduction",
    "text": "Introduction\nLab 3 involved learning how to synchronize asynchronous inputs from a 4x4 keypad and use FSMs for memory to display the most recent input from the keypad as the right digit of a dual 7-segment display and the last input as the left digit."
  },
  {
    "objectID": "labs/lab3/lab3.html#design-and-testing-methodology",
    "href": "labs/lab3/lab3.html#design-and-testing-methodology",
    "title": "Lab 3 Report",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\n\nDual Display with one 7-Segment Module\nIn order to display two independent hexadecimal numbers on the dual 7-segment display using only one sevseg module, the trick was to send the same output to both digits but alternate between turning on the first digit and the second digit fast enough that the different digits are seen at the same time to our eyes (~60 Hz). To alternate between the two, the on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library was used to generate a clock signal at 24 MHz then a counter was used to divide the high frequency clock signal into a 60 Hz signal.\n\n\n\n\n\n\nFigure 1: The calculation for the counter to make the inputs and output powers alternate at 60 Hz.\n\n\n\nThe calculation in Figure 1 derived that the counter needed to reach 200000 before setting the multiplexer select HIGH in order switch between the two inputs and turning on the two outputs at 60 Hz. For example, if the first digit should read 1 and then second digit should read 5, then when clk is LOW, the program takes 1 as the input and sends 1 to both digits’ outputs. Then, the program turns only the first digit’s power on and turns the other digit’s power off. When clk is HIGH, the program takes 5 as the input and sends 5 to both digits’ outputs. Then the program turns the second digit’s power on and turns the first digit’s power off. This switch happens fast enough that the human eye sees both individual digits on the display.\n\n\nResistor choice for 7-segment Display\n\n\n\n\n\n\nFigure 2: The calculation for the 7-segment current-limiting resistors using a V_f of 1.9V from the MAN4600 datasheet.\n\n\n\nThe calculation in Figure 2 derived 1kΩ as an appropriate resistor to provide ~1.2 mA to the LED segments of the 7-segment display. The drop in voltage from the emitter is due to the emitter saturation voltage. Thus the voltage going into the segment displays is 3.1 V.\n\n\nResistor choice for transistors\n\n\n\n\n\n\nFigure 3: The calculation for the transistor current-limiting resistors using a V_f of 0.7V for the emitter diode such that the base voltage is 2.6V.\n\n\n\nThe calculation in Figure 3 derived 2.7kΩ as an appropriate resistor (stock-room available) to provide less than 1 mA to FPGA I/O pins.\n\n\nResistor choice for keypad inputs\nIn order to read the keypad keys, I chose to have my columns as one of my top module’s outputs. This means my program drives power to the columns and checks the rows for a press. I also chose to implement an active HIGH keypad, which means I needed pulldown resistors for the row inputs such that when there is no activity, the rows read 4'b0000. I chose 680Ω as the resistors to be large enough so as to not draw too much current from the FPGA pins and small enough to quickly pull down the signal and act as a pulldown resistor.\n\n\nDebounce design and FSM diagrams\nOne of the mechanical issues with the keypad buttons is that the buttons “bounce” when pressed. I chose to debounce my keypad buttons using an 3-state FSM that waits for a button to be pressed, then when the button was pressed the FSM would enter a state that waits for a counter to reach high enough that the button would have stabilized, then when the counter reaches a set number the FSM would enter a state that waits for the button to be released.\n\n\n\n\n\n\nFigure 4: Scanner FSM state transition diagram and state transition table.\n\n\n\n\n\n\n\n\n\nFigure 5: Debouncer and Digit FSM state transition diagram and state transition table.\n\n\n\nThe images above detail the design of the three FSMs that I used in my overall implementation. One FSM was to switch between scanning for rows and holding when a key was pressed (Figure 4). Another FSM was the debouncing FSM to only register the keypress once (Figure 5). And the digit FSM was for switching between updating the digits and not updating the digits (Figure 5). The FSM is a simple strategy to store an input in “memory” and use this memory to decide what to do at the next clock cycle. However, some of the tradeoffs with the FSM is that the inputs and timing can get really tricky especially in this lab where multiple FSMs needed to communicate with each other."
  },
  {
    "objectID": "labs/lab3/lab3.html#technical-documentation",
    "href": "labs/lab3/lab3.html#technical-documentation",
    "title": "Lab 3 Report",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for the project can be found in the associated Github repository\n\nBlock Diagram\n\n\n\n\n\n\nFigure 6: Block diagram showing the top module and the submodules HSOSC, scanner, debouncer, synchronizer, digit,keypad,mpx, andsevseg`.\n\n\n\nThe block diagram in Figure 6 demonstrates the overall architecture of the design. The top-level module top includes 8 submodules: the high-speed oscillator block (HSOSC), the scanner to check for keypad presses, the debouncer to debounce the button presses, the synchronizer to synchronizer the row and col signals, the digit module to send the debounced signal either to the right digit and send the previous right digit to the left digit, the keypad module to decode a row and col pair into a key on the keypad, and finally the multiplexer to alternate at 60 Hz (mpx) and the 7-segment display module from Lab 1 (sevseg)."
  },
  {
    "objectID": "labs/lab3/lab3.html#schematic",
    "href": "labs/lab3/lab3.html#schematic",
    "title": "Lab 3 Report",
    "section": "Schematic",
    "text": "Schematic\n\n\n\n\n\n\nFigure 7: Schematic of the layout not including the the reset button (P43). The diodes of each digit of the 7-segment display share a common anode.\n\n\n\nFigure 7 shows the physical layout of the design. The output 7-segment diodes were connected using a 1kΩ current-limiting resistor to ensure the output current (~1.4 mA) did not exceed the maximum output current of the FPGA I/O pins. The figure also shows which pin number of the dual display corresponds to which segment (i.e. A1,A2,B1, B2…) of the 7-segment display.\n\n\n\n\n\n\nFigure 8: Diagram of the letter assignment for the 7-segment display.\n\n\n\nFigure 8 depicts the assignment of letters to a digit of the output display. In the program, seg[0] corresponds to a, seg[1] to b, and so on."
  },
  {
    "objectID": "labs/lab3/lab3.html#results-and-discussion",
    "href": "labs/lab3/lab3.html#results-and-discussion",
    "title": "Lab 3 Report",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench Simulation\n\ntop Module (HSOSC implied)\n\n\n\n\n\n\nFigure 9: Testbench simulation results for top module. The simulation shows outputs match expected outputs for all asserts\n\n\n\nThe design met all intended design objectives. Figure 9 shows a screenshot of the QuestaSim simulation for the top module’s testbench tb_top. Because all the outputs depend on HSOSC it can be assumed that HSOSC toggles. As shown in Figure 9, the simulated outputs of seg change when expected in relation to the led0 which holds the value for whether the button is debounced and counter from the mpx module which updates what key to send to the seg module. seg is expected then to change after the button is debounced (db/counter reaches 500000) and the mpx sends seg the key to output (db/mpx reaches 200000). I wrote tests for all 16 keys that seg matches expected for when the button is pressed, when another button is pressed while the first one is still pressed, and when the button is released. Although not pictured, the testbench passed all tests for all 16 keys.\n\n\nscanner Module\n\n\n\n\n\n\nFigure 10: Testbench simulation results for scanner module. The simulation shows outputs match expected outputs for all asserts\n\n\n\nFigure 10 shows that the scanner module reaches all scanning states when no row is input and reaches all pressed states when a row is input at the corresponding column. At the end of the simulation, the image shows that the scanner module also correctly stays in the PRESSED state even when a new input key is pressed while the first key is held.\n\n\ndebouncer Module\n\n\n\n\n\n\nFigure 11: Testbench simulation results for debouncer module. The simulation shows the correct states as expected with the set inputs.\n\n\n\nFigure 11 shows that the debouncer module moves from S0 (waiting for key press) to S1 when a key is registered and correctly stays in the S1 state of waiting for debounced to go high (counter to reach 500000) even when a new input key is pressed while the first key is held.\n\n\n\n\n\n\nFigure 12: Testbench simulation results for debouncer module. The simulation shows the correct states as expected with the set inputs.\n\n\n\nFigure 12 shows that the debouncer module moves from S1 (waiting for debounced) to S2 when debounced goes high and stays in the S2 state of waiting for the button to be released even when a new input key is pressed while the first key is held. The FSM also correctly moves back to S0 when the button is released (row input is 4'b0000). debounced also correctly goes high after the counter counts up to 500000.\n\n\nsynchronizer Module\n\n\n\n\n\n\nFigure 13: Testbench simulation results for synchronizer module. The simulation shows outputs match expected outputs for all asserts.\n\n\n\nFigure 13 shows that the synchronizer module correctly transfers the asynchronous input to the synchronized output after 4 clock cycles. The choice of 4 clock cycles was for the synchronized output to match the right SCANNING state in the scanner module, and there are 4 scanning states to run through in the scanning cycle.\n\n\ndigit Module\n\n\n\n\n\n\nFigure 14: Testbench simulation results for digit module. The simulation shows outputs match expected outputs for all asserts.\n\n\n\nFigure 14 shows that the digit module visits all 3 states. The module correctly does not transfer any information when in the NOUPDATE state and correctly transfers the most recent input only to the right row/col and updates the left row/col with the previous values of the right row/col in the UPDATE state. The module also correctly only updates the right and left rows/cols by moving to the FINISHEDUPDATE state after updating once as well as returns to NOUPDATE when the debounced signal goes back to 0 (debouncer module is back to waiting for a button to be pressed).\n\n\nkeypad Module\n\n\n\n\n\n\nFigure 15: Testbench simulation results for keypad module. The simulation shows outputs match expected outputs for all asserts.\n\n\n\nFigure 15 shows that the keypad module correctly matches a row and column pair to its corresponding key on the 4x4 keypad.\n\n\nsevseg Module\n\n\n\n\n\n\nFigure 16: Testbench simulation results for the sevseg module. The simulation shows outputs match expected outputs for all testvectors\n\n\n\nFigure 16 shows a screenshot of the QuestaSim simulation for the sevseg module’s testbench tb_sevseg. The simulated outputs of seg match the expected outputs.\n\n\nmpx Module\n\n\n\n\n\n\nFigure 17: Testbench simulation results for the mpx module for before the flip. The simulation shows outputs match expected outputs for all asserts\n\n\n\nFigure 17 shows a screenshot of the QuestaSim simulation for the mpx module’s testbench tb_mpx to test that the s, trans0, and trans1 output matches the expected outputs for before the alternation (aka flip) at counter = 200000. Because we are before the flip, s should be the same as the s0 input and trans0 and trans1 should be 0 and 1 respectively. The simulated outputs of mpx match the expected outputs for before the flip and the counter is counting up.\n\n\n\n\n\n\nFigure 18: Testbench simulation results for the mpx module for after the flip. The simulation shows outputs match expected outputs for all testvectors\n\n\n\nFigure 18 shows a screenshot of the QuestaSim simulation for the mpx module’s testbench tb_mpx to test that the s, trans0, and trans1 output matches the expected outputs for after the alternation (aka flip) that should occur when the counter reaches 200000. Because we are after the flip, s should be the same as the s1 input and trans0 and trans1 should be 1 and 0 respectively. The simulated outputs of mpx match the expected outputs for after the flip and the flip happens when the counter reaches 200000. The reset of the counter after count reaches 200000 is also visualized."
  },
  {
    "objectID": "labs/lab3/lab3.html#conclusion",
    "href": "labs/lab3/lab3.html#conclusion",
    "title": "Lab 3 Report",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully read inputs from the 4x4 keypad and displayed the most recent input on the right digit of a dual 7-segment display and the last input on the left digit. The design does not lock up when multiple buttons are pressed. Each button press is only registered once and the 7-segment displays are the same brightness. The design has no latchesor tristate buffers. The design also uses synchronizers and only registers the first button press if additional buttons are pressed down while holding down one button. There is no bleeding between the digits or flickering and the 7-segment display does not dim depending on which numbers are displayed. The digits are also upright to the viewer.\nOverall a success!"
  },
  {
    "objectID": "labs/lab3/lab3.html#ai-prototype-and-reflection",
    "href": "labs/lab3/lab3.html#ai-prototype-and-reflection",
    "title": "Lab 3 Report",
    "section": "AI Prototype and Reflection",
    "text": "AI Prototype and Reflection\n\nPrototype A: Monolithic Prompt\nThe Claude AI produced a code with 4 modules: a keypad_top module that drives columns and checks rows, a clk_divider module that is used both for scanning and display,a keypad_scanner module that jumps from scanning the different columns to a key-hold state to a key-release state, and a display controller with time multiplexing to alterante between the digits of the disp_clk rate and also holds the 7-segment decoder of what segments to activate on the display. The code actually synthesized on the first try which suprised me. Usually it takes a couple errors fed back into the AI to get a synthesizable code. Something that was interesting to me was that the code in the keypad_scanner module saved the pressed key as an array with the active column and the input low row. I also thought that later in the same module, the output register had a really interesting implementation of having a variable holding whether the key is valid that relies on whether the next state is the KEY_RELEASED state.\n\n\nPrototype A Scanner Register Code\n\nalways_ff @(posedge scan_clk or negedge rst_n) begin\n        if (!rst_n) begin\n            key_code  &lt;= 4'h0;\n            key_valid &lt;= 1'b0;\n        end else begin\n            key_valid &lt;= (next_state == KEY_RELEASED);  // Pulse on key release\n            if (key_detected && (state != KEY_HELD)) begin\n                key_code &lt;= pressed_key;\n            end\n        end\n    end\n\nI thought this was an interesting implementation since I’ve always been taught to put this kind of logic in an always_comb and to add more states if needed rather than to put the logic in the flop register. I didn’t use active-low in my design, but I heard many people had issues with getting one of the specs of holding down one button then pressing another button in the same column (if driving columns and checking rows) then releasing the first button and keeping the second button pressed and registering the second button once. The idea of a key_valid in the flop could possibly circumvent this, but it’s hard to check without having an active-low hardware implementation to test on.\nThere were way less FSMs than in my implementation. The keypad_scanner module also used the slowed down clock from clk_driver to work the FSM state register. I believe this was to address the problem of debouncing which was different from my implementation of using an FSM.\n\n\nPrototype B: Modular Prompts\nThis time the Claude AI produced 3 modules: keypad_top, keypad_scanner, and keypad_oneshot. However, the design did not synthesize due to the use of the SB_HFOSC module which we are not using. This was an issue I’ve run into in the first lab AI prototype. After telling the AI to use HSOSC instead, the code ran into another issue of instantiating unknown modules for sevenSegment. Feeding this into the AI caused the AI to build the module which then allowed the code to synthesize!\nThe debounce FSM was actually very similar to my own FSM with an IDLE, DEBOUNCE, KEY_HELD, and WAIT_RELEASE state. I actually ended up only using three states for idle, waiting for debounce, and waiting for release. In terms of synthesizability, the modular prompts needed more help and guidance to produce a synthesizable code. Because I’m more familiar with FSM structure, it was a little easier to follow than the monolithic prompt. However, the size of the code with so many FSMs does mean the readability decreases a bit. This could also be in part due to having all the modules on the same file. I had a lot of timing issues in my own code while debugging, and what I see with this code is that a lot of the variables that deal with FSM states are computed internally in the module when possible as opposed to grabbing the necessary input from other FSMs. The modular prompt also caused the clock dividing to be placed in the keypad_top module rather than in a separate clk_divider module which also reduced readability."
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1 Report",
    "section": "",
    "text": "I spent 24 hours working on this lab."
  },
  {
    "objectID": "labs/lab1/lab1.html#lab-hours",
    "href": "labs/lab1/lab1.html#lab-hours",
    "title": "Lab 1 Report",
    "section": "",
    "text": "I spent 24 hours working on this lab."
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction",
    "href": "labs/lab1/lab1.html#introduction",
    "title": "Lab 1 Report",
    "section": "Introduction",
    "text": "Introduction\nLab 1 dealt with setting up and testing the FPGA including soldering all parts of the board and writing SystemVerilog code to verify the LEDs and interface with a 7-segment display on a breadboard."
  },
  {
    "objectID": "labs/lab1/lab1.html#design-and-testing-methodology",
    "href": "labs/lab1/lab1.html#design-and-testing-methodology",
    "title": "Lab 1 Report",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\n\nBlinking LED2\nThe on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library was used to generate a clock signal at 24 MHz. Then, a counter was used to divide the high frequency clock signal to drive an external LED (LED2) such that it blinks at 2.4 Hz.\n\n\n\n\n\n\nFigure 1: The calculation for the counter to make LED2 blink at 2.4 Hz.\n\n\n\nThe calculation in Figure 1 derived that the counter needed to reach 5000000 before setting the LED HIGH in order to blink the LED at 2.4 Hz with a 50% duty cycle.\n\n\nResistor choice for 7-segment Display\n\n\n\n\n\n\nFigure 2: The calculation for the 7-segment current-limiting resistors using a V_f of 1.9V from the MAN4600 datasheet.\n\n\n\nThe calculation in Figure 2 derived 1kΩ as an appropriate resistor to provide ~1.9 mA to the LED segments."
  },
  {
    "objectID": "labs/lab1/lab1.html#technical-documentation",
    "href": "labs/lab1/lab1.html#technical-documentation",
    "title": "Lab 1 Report",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for the project can be found in the associated Github repository\n\nBlock Diagram\n\n\n\n\n\n\nFigure 3: Block diagram showing the top module and the two submodules HSOSC and sevensegment.\n\n\n\nThe block diagram in Figure 3 demonstrates the overall architecture of the design. The top-level module top includes two submodules: the high-speed oscillator block (HSOSC) and the 7-segment display module (sevensegment). The programming for the leds were placed in the top module."
  },
  {
    "objectID": "labs/lab1/lab1.html#schematic",
    "href": "labs/lab1/lab1.html#schematic",
    "title": "Lab 1 Report",
    "section": "Schematic",
    "text": "Schematic\n\n\n\n\n\n\nFigure 4: Schematic of the layout including the SW6 switch. The 7-segment display shares a common anode.\n\n\n\nFigure 4 shows the physical layout of the design. An internal 100 kΩ pullup resistor was used to ensure the active low reset pin for the switches was not floating. The output 7-segment diodes were connected using a 1kΩ current-limiting resistor to ensure the output current (~1.2 mA) did not exceed the maximum output current of the FPGA I/O pins. The figure also shows which pin number corresponds to which segment (i.e. a,b,c…) of the 7-segment display.\n\n\n\n\n\n\nFigure 5: Diagram of the letter assignment for the 7-segment display.\n\n\n\nFigure 5 depicts the assignment of letters to the output display. In the program, seg[0] corresponds to a, seg[1] to b, and so on."
  },
  {
    "objectID": "labs/lab1/lab1.html#results-and-discussion",
    "href": "labs/lab1/lab1.html#results-and-discussion",
    "title": "Lab 1 Report",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench Simulation\n\n\n\n\n\n\nFigure 6: Testbench simulation results for top module. Note the red comes from the blinking LED bit. The simulation shows outputs match expected outputs for all testvectors\n\n\n\nThe design met all intended design objectives. Figure 6 shows a screenshot of the QuestaSim simulation for the top module’s testbench tb_top. The simulated outputs of led and seg match their respective expected outputs.\n\n\n\n\n\n\nFigure 7: Testbench simulation results for sevensegment module. The simulation shows outputs match expected outputs for all testvectors\n\n\n\nFigure 7 shows a screenshot of the QuestaSim simulation for the sevensegment module’s testbench tb_sevseg. The simulated outputs of seg match the expected outputs.\nIf the design wanted to reuse the clock divider program, a separate module could be developed for the clock divider that takes the HSOSC int_osc output as an input."
  },
  {
    "objectID": "labs/lab1/lab1.html#conclusion",
    "href": "labs/lab1/lab1.html#conclusion",
    "title": "Lab 1 Report",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully blinked LED2 using the on-board high-speed oscillator, programmed LED1 and LED0 to the given truth table corresponding to s[3:2] and s[1:0] respectively, and displayed on the 7-segment display a single hexadecimal digit corresponding to the switches s[3:0] such that each digit is unique/distinguishable from the rest."
  },
  {
    "objectID": "labs/lab1/lab1.html#ai-prototype-and-reflection",
    "href": "labs/lab1/lab1.html#ai-prototype-and-reflection",
    "title": "Lab 1 Report",
    "section": "AI Prototype and Reflection",
    "text": "AI Prototype and Reflection\nThe first run with Claude AI produced a code very similar to the one I had written for the led_blinker by toggling the led under an always_ff statement with the counter. Some key differences was that the program used the SB_HFOSC module rather than the HSOSC which was new to me and was also unrecognized by Radiant giving a “instantiating unknown module” error.\nAfter feeding the error back into the LLM, the LLM fed back to declare the primitive with blackbox attribute which is also completely new to me. However parsing this still provided an error that CLKHF_DIV is not defined in this module. The instantiation of the SB_HFOSC module seemed to run into an error where the parameter in the module was not defined when later used in the module.\nAnother key difference and something new to me was that the program used localparam int to initialize a maximum counter and the width of the counter. The width of the counter used the code $clog2(COUNTER_MAX + 1) which I have never seen.\nIf I were to use the LLM again, I would like to tell the LLM what modules to use. The issue seemed to be with SB_HFOSC so feeding the LLM explicitly to use HSOSC could be quicker to getting towards a working code. Doing this actually changed the error to duplicate module name because the LLM program was trying to delcare the HSOSC primitive. Then feeding this error the LLM replied that the error is likely due to the HSOSC module already being available and it deleted the primitive declaration. After this deletion the code synthesized with no errors!\nI think the quality of the output is quite high. Each new section of code is commented with an overarching comment of the module’s function at the top. The only thing is that the LLM can get really stuck on executing the code one way and sometimes better quality code can be written by knowing multiple avenues of which to implement the code. So feeding the desired packages or modules can be really helpful in producing successful LLM code."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Hello Quarto\n\n\nWelcome to my Quarto portfolio\n\n\n\n\n\nAug 28, 2025\n\n\nErin Wang\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 1 Reflections\n\n\nBuilding my development board and programming in Verilog\n\n\n\n\n\nAug 28, 2025\n\n\nErin Wang\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Erin Wang is a senior engineering major at Harvey Mudd College. Her interests are in robotics and mechatronics specifically for building animatronics in theme parks. One of her personal projects is to build the robot from the REPO game with 3D printed material and off-the-shelf servo motors. The link to her Github can be found here.\nAfter college, she aims to apply for Masters programs robotics, electrical engineering, or mechanical engineering. When she is not working hard in her classes, music and food fill her life. She loves to dance and sing as well as compose music, and she is always willing to try a new food place."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2 Report",
    "section": "",
    "text": "I spent 20 hours on this lab."
  },
  {
    "objectID": "labs/lab2/lab2.html#lab-hours",
    "href": "labs/lab2/lab2.html#lab-hours",
    "title": "Lab 2 Report",
    "section": "",
    "text": "I spent 20 hours on this lab."
  },
  {
    "objectID": "labs/lab2/lab2.html#introduction",
    "href": "labs/lab2/lab2.html#introduction",
    "title": "Lab 2 Report",
    "section": "Introduction",
    "text": "Introduction\nLab 2 involved learning time multiplexing and application of PNP transistors to efficiently use the I/O on the FPGA by using one module and two 4 DIP switch inputs to control a dual 7-segment display on a breadboard. The lab also involved displaying the sum of the two inputs onto external LEDs."
  },
  {
    "objectID": "labs/lab2/lab2.html#design-and-testing-methodology",
    "href": "labs/lab2/lab2.html#design-and-testing-methodology",
    "title": "Lab 2 Report",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\n\nDual Display with one 7-Segment Module\nIn order to display two independent hexadecimal numbers on the dual 7-segment display using only one sevseg module, the trick was to send the same output to both digits but alternate between turning on the first digit and the second digit fast enough that the different digits are seen at the same time to our eyes (~60 Hz). To alternate between the two, the on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library was used to generate a clock signal at 24 MHz then a counter was used to divide the high frequency clock signal into a 60 Hz signal.\n\n\n\n\n\n\nFigure 1: The calculation for the counter to make the inputs and output powers alternate at 60 Hz.\n\n\n\nThe calculation in Figure 1 derived that the counter needed to reach 200000 before setting the multiplexer select HIGH in order switch between the two inputs and turning on the two outputs at 60 Hz. For example, if the first digit should read 1 and then second digit should read 5, then when clk is LOW, the program takes 1 as the input and sends 1 to both digits’ outputs. Then, the program turns only the first digit’s power on and turns the other digit’s power off. When clk is HIGH, the program takes 5 as the input and sends 5 to both digits’ outputs. Then the program turns the second digit’s power on and turns the first digit’s power off. This switch happens fast enough that the human eye sees both individual digits on the display.\n\n\nResistor choice for 7-segment Display\n\n\n\n\n\n\nFigure 2: The calculation for the 7-segment current-limiting resistors using a V_f of 1.9V from the MAN4600 datasheet.\n\n\n\nThe calculation in Figure 2 derived 1kΩ as an appropriate resistor to provide ~1.2 mA to the LED segments of the 7-segment display. The drop in voltage from the emitter is due to the emitter saturation voltage. Thus the voltage going into the segment displays is 3.1 V.\n\n\nResistor choice for external LEDs\n\n\n\n\n\n\nFigure 3: The calculation for the external LEDs current-limiting resistors using a V_f of 1.9V from the green LED datasheet.\n\n\n\nThe calculation in Figure 3 derived 1kΩ as an appropriate resistor to provide ~1.4 mA to the external LEDs. The calculation is the same as for the 7-segment display, however the cathodes of the LEDs are connected to ground rather than to a pin.\n\n\nResistor choice for transistors\n\n\n\n\n\n\nFigure 4: The calculation for the transistor current-limiting resistors using a V_f of 0.7V for the emitter diode such that the base voltage is 2.6V.\n\n\n\nThe calculation in Figure 4 derived 2.7kΩ as an appropriate resistor (stock-room available) to provide less than 1 mA to FPGA I/O pins."
  },
  {
    "objectID": "labs/lab2/lab2.html#technical-documentation",
    "href": "labs/lab2/lab2.html#technical-documentation",
    "title": "Lab 2 Report",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for the project can be found in the associated Github repository\n\nBlock Diagram\n\n\n\n\n\n\nFigure 5: Block diagram showing the top module and the three submodules HSOSC, mpx, and sevseg.\n\n\n\nThe block diagram in Figure 5 demonstrates the overall architecture of the design. The top-level module top includes three submodules: the high-speed oscillator block (HSOSC), the multiplexer to alternate at 60 Hz (mpx), and the 7-segment display module from Lab 1 (sevseg). The programming for the LED sum and the multiplexer logic using the select output of mpx were placed in the top module."
  },
  {
    "objectID": "labs/lab2/lab2.html#schematic",
    "href": "labs/lab2/lab2.html#schematic",
    "title": "Lab 2 Report",
    "section": "Schematic",
    "text": "Schematic\n\n\n\n\n\n\nFigure 6: Schematic of the layout not including the SW6 switch or the reset button (P43). The diodes of each digit of the 7-segment display share a common anode.\n\n\n\nFigure 6 shows the physical layout of the design. An internal 100 kΩ pullup resistor was used to ensure the active low reset pin for the switches was not floating. The output 7-segment diodes were connected using a 1kΩ current-limiting resistor to ensure the output current (~1.4 mA) did not exceed the maximum output current of the FPGA I/O pins. The external LED diodes (green) were connected using a 1kΩ current-limiting resistor to ensure the output current (~1.4 mA) did not exceed the maximum output current of the LEDs. The figure also shows which pin number of the dual display corresponds to which segment (i.e. A1,A2,B1, B2…) of the 7-segment display.\n\n\n\n\n\n\nFigure 7: Diagram of the letter assignment for the 7-segment display.\n\n\n\nFigure 7 depicts the assignment of letters to a digit of the output display. In the program, seg[0] corresponds to a, seg[1] to b, and so on."
  },
  {
    "objectID": "labs/lab2/lab2.html#results-and-discussion",
    "href": "labs/lab2/lab2.html#results-and-discussion",
    "title": "Lab 2 Report",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench Simulation\n\ntop Module\n\n\n\n\n\n\nFigure 8: Testbench simulation results for top module showing the HSOSC toggling. The simulation shows outputs match expected outputs for all asserts\n\n\n\nThe design met all intended design objectives. Figure 8 shows a screenshot of the QuestaSim simulation for the top module’s testbench tb_top after approximately #10000 time units to show that the HSOSC toggles.\n\n\n\n\n\n\nFigure 9: Testbench simulation results for top module showing the outputs for the LED. The simulation shows the LED outputs match expected outputs for all asserts\n\n\n\nAs shown in Figure 9, the simulated outputs of led match the ledexpected output. Note that not all the tested inputs of led are shown in this image. The outputs of top: seg, trans0, and trans1 are not tested in this testbench because they rely on the mpx module which uses the HSOSC clock to provide the transistor output and switch input into sevseg. The outputs for seg are tested in the sevseg testbench while trans0 and trans1 and the switch input into sevseg are tested in the mpx testbench.\n\n\nsevseg Module\n\n\n\n\n\n\nFigure 10: Testbench simulation results for the sevseg module. The simulation shows outputs match expected outputs for all testvectors\n\n\n\nFigure 10 shows a screenshot of the QuestaSim simulation for the sevseg module’s testbench tb_sevseg. The simulated outputs of seg match the expected outputs.\n\n\nmpx Module\n\n\n\n\n\n\nFigure 11: Testbench simulation results for the mpx module for before the flip. The simulation shows outputs match expected outputs for all asserts\n\n\n\nFigure 11 shows a screenshot of the QuestaSim simulation for the mpx module’s testbench tb_mpx to test that the s, trans0, and trans1 output matches the expected outputs for before the alternation (aka flip) at counter = 200000. Because we are before the flip, s should be the same as the s0 input and trans0 and trans1 should be 0 and 1 respectively. The simulated outputs of mpx match the expected outputs for before the flip and the counter is counting up.\n\n\n\n\n\n\nFigure 12: Testbench simulation results for the mpx module for after the flip. The simulation shows outputs match expected outputs for all testvectors\n\n\n\nFigure 12 shows a screenshot of the QuestaSim simulation for the mpx module’s testbench tb_mpx to test that the s, trans0, and trans1 output matches the expected outputs for after the alternation (aka flip) that should occur when the counter reaches 200000. Because we are after the flip, s should be the same as the s1 input and trans0 and trans1 should be 1 and 0 respectively. The simulated outputs of mpx match the expected outputs for after the flip and the flip happens when the counter reaches 200000. The reset of the counter after count reaches 200000 is also visualized."
  },
  {
    "objectID": "labs/lab2/lab2.html#conclusion",
    "href": "labs/lab2/lab2.html#conclusion",
    "title": "Lab 2 Report",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully displayed two individual digits on the dual 7-segment display using only one sevseg module. The 5 LEDs also successfully display the sum of the two inputs. There is no bleeding between the digits or flickering and the 7-segment display does not dim depending on which numbers are displayed. The digits are also upright to the viewer."
  },
  {
    "objectID": "labs/lab2/lab2.html#ai-prototype-and-reflection",
    "href": "labs/lab2/lab2.html#ai-prototype-and-reflection",
    "title": "Lab 2 Report",
    "section": "AI Prototype and Reflection",
    "text": "AI Prototype and Reflection\n\nWithout Lab 1 Files Provided\nOff the bat I already recognized the Claude Ai put multiple modules in one file and the testbench module in another file. When trying to synthesize the code, there was an error in the testbench module. The testbench had two initial statements. The first initial statement housed the error of loop count limit exceeded forever never breaks. This is because the AI had setup the clock with the following code:\ninitial begin\n    clk = 0;\n    forever #5 clk = ~clk;\nend\nThis block of code is notably different from how I implement a clock. I use an always statement instead of initial to setup the clock.\nJust attempting to synthesize without including the testbench in implementation does work! Looking at theseven_seg_decoder module from the AI, the case statement looks like mine, accomodating for the common anode by having 1 as LOW and 0 as HIGH for the display. There is however no default case which could be a problem for debugging. The seven_seg_mux module uses the same clock divider setup as the provided example on the E155 website by using a counter and setting the multiplexer’s select to the last bit. What’s more strikingly different is that the input multiplexer code is an always_comb statement whereas I used the syntax for a multiplexer of select ? in1:in0. The AI also used an always_ff statement for the output demultiplexer with latches by turning the output to either all segments off or all segments on. However, we were told explicitly not to use latches and to use PNP transistors to control the anode power.\n\n\nWith Lab 1 Files Provided\nWith the Lab 1 files provided, the AI did not provide a testbench. The code was much shorter than without the Lab 1 files. The code does use HSOSC immediately which is different from the Lab 1 AI Prototype. For the time multiplexing, the AI created a clock divider to toggle at 1200 Hz. This seems a little high to me as a computer screen is around 60 Hz. Such high frequency could cause some bleeding between digits. The code for the multiplexer select is how I did the select in my code where the counter resets and the mux select switches to its opposite logic after a certain number of counts. The input multiplexer code was still an always_comb statement rather than the select ? in1:in0 format. The code then uses my sevensegment module to input the switch chosen from the always_comb statement and outputs the segments to turn on. The AI this time uses an always_comb for the output demultiplexer to use the multiplexer select from the clock divider to choose whether to make the first digit active and the second display off or vice versa. The default display is that both displays are off.\nThe code also provides a small section to use LEDs to check which display is active, check when the two inputs differ, and to blink at the frequency of the clock divider.\nOverall, I think both codes are very high quality although may be a little wordy considering mux logic can be much shorter than an always_comb statement. The code was interesting to compare as we didn’t specify to the AI to send an output to PNP transistors to control which digit was on and I think the prototype had a clever way of sending the output to the LED segments."
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 4 Report",
    "section": "",
    "text": "I spent 30 hours on this lab."
  },
  {
    "objectID": "labs/lab4/lab4.html#lab-hours",
    "href": "labs/lab4/lab4.html#lab-hours",
    "title": "Lab 4 Report",
    "section": "",
    "text": "I spent 30 hours on this lab."
  },
  {
    "objectID": "labs/lab4/lab4.html#introduction",
    "href": "labs/lab4/lab4.html#introduction",
    "title": "Lab 4 Report",
    "section": "Introduction",
    "text": "Introduction\nLab 4 involved learning how to setup header files for the MCU by practicing making a header file for the timers TIM15 and TIM16 as well as in writing to registers to output frequencies corresponding to different notes."
  },
  {
    "objectID": "labs/lab4/lab4.html#design-and-testing-methodology",
    "href": "labs/lab4/lab4.html#design-and-testing-methodology",
    "title": "Lab 4 Report",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\n\nVerifying 1% Accuracy for 220 Hz to 1000 Hz Frequencies\nIn order to create a PWM of different frequencies, I made use of timer TIM16 on the MCU to slow down an incoming clock and turn on and off given a number of ticks corresponding to the period of the input frequency. The divider for the incoming clock had to be selected in order to accomodate 220 Hz to 1000 Hz without overflowing the prescaler or the timer counter. I was able to control the AHB2, APB2, and TIM16 prescaler. However, I chose only to manipulate the 16-bit TIM16 prescaler as it had greater flexibility with being able to be set to values 1 to 65536 and meant that the other peripherals using AHB2 and APB2 wouldn’t be affected by a slower clock. Because I used the PLL as the SYSCLK, the incoming signal to TIM16 was 80 MHz. I chose the AHB2 prescaler to be /1, the APB2 prescaler to be /1, and the TIM16 prescaler to be 7. With the TIM16 prescaler (PSC). the input clock to TIM16 is divided by PSC + 1such that\n\\[\nTIM16_{frequency} = {\\frac{80 MHz}{7+1}} = 10 MHz\n\\]\nBecause the TIM16 counter upcounts everytime it sees a clock edge that means that at an incoming 10 MHz clock provides 10000000 ticks per second. However, due to the limitations of the MCU, the division rounds down. This results in the following discrepancy between input and output note frequency:\n\nFor 220 Hz…\n\\[\nactual\\:counter = {\\frac{10000000 {\\frac{ticks}{s}}}{220 {\\frac{1}{s}}}} = 45454.54545 \\: ticks\n\\] \\[\ncalculated\\:counter = {\\frac{10000000 {\\frac{ticks}{s}}}{220 {\\frac{1}{s}}}} = 45454 : ticks\n\\] \\[\ncalculated\\:frequency = {\\frac{10000000 {\\frac{ticks}{s}}}{45454 \\:ticks}} = 220.0026400317 Hz\n\\]\n\\[\n\\begin{align*}\npercent \\: difference &= {\\frac{calculated \\: frequency - actual \\: frequency}{actual \\: frequency}} * 100\\% \\\\\n&= {\\frac{220.0026400317 Hz - 220 Hz}{220 Hz}} * 100\\% \\\\\n&= 0.0012\\%\n\\end{align*}\n\\]\n\n\nFor 1000 Hz…\n\\[\nactual\\:counter = {\\frac{10000000 {\\frac{ticks}{s}}}{1000 {\\frac{1}{s}}}} = 10000 \\: ticks\n\\] \\[\ncalculated\\:counter = {\\frac{10000000 {\\frac{ticks}{s}}}{1000 {\\frac{1}{s}}}} = 10000 \\: ticks\n\\] \\[\ncalculated\\:frequency = {\\frac{10000000 {\\frac{ticks}{s}}}{10000 \\:ticks}} = 1000 Hz\n\\]\n\\[\n\\begin{align*}\npercent \\: difference &= {\\frac{calculated \\: frequency - actual \\: frequency}{actual \\: frequency}} * 100\\% \\\\\n&= {\\frac{1000 Hz - 1000 Hz}{10000 Hz}} * 100\\% \\\\\n&= 0\\%\n\\end{align*}\n\\]\n\n\nFor random 337 Hz…\n\\[\nactual\\:counter = {\\frac{10000000 {\\frac{ticks}{s}}}{337 {\\frac{1}{s}}}} = 29673.590504451 \\: ticks\n\\] \\[\ncalculated\\:counter = {\\frac{10000000 {\\frac{ticks}{s}}}{337 {\\frac{1}{s}}}} = 29673 \\: ticks\n\\] \\[\ncalculated\\:frequency = {\\frac{10000000 {\\frac{ticks}{s}}}{29673 \\:ticks}} = 337.0067064335 Hz\n\\]\n\\[\n\\begin{align*}\npercent \\: difference &= {\\frac{calculated \\: frequency - actual \\: frequency}{actual \\: frequency}} * 100\\% \\\\\n&= {\\frac{337.0067064335 Hz - 337 Hz}{337 Hz}} * 100\\% \\\\\n&= 0.00199\\%\n\\end{align*}\n\\]\n\n\nExpected Range Conclusion\nTherefore, the PSC of 7 allows for individual pitches to be calculated within %1 accuracy when between 220 Hz and 1000 Hz.\n\n\n\nMax/Min Duration\nFor the note duration, I used TIM15 for my delay and set the PSC to 7999 such that the incoming clock would be as such.\n\\[\nTIM15_{frequency} = {\\frac{80 MHz}{7999+1}} = 10 kHz\n\\]\nAccording to the STM reference manual, the TIM15 counter is able to go from 1 to 65536. Using these values, the calculated max and min durations are as follows.\n\nMax Duration\n\\[\nmax \\: duration = {\\frac{655356 \\: ticks}{10000 {\\frac{ticks}{s}}}} = 6.5536 \\: s = 6553.6 \\: ms\n\\]\n\n\nMin Duration\n\\[\nmin \\: duration = {\\frac{1 \\: tick}{10000 {\\frac{ticks}{s}}}} = 0.0001 \\: s = 0.1 \\: ms\n\\]\n\n\nDuration Conclusion\nBy calculation the theoretical max/min duration are 6553.6 ms and 0.1 ms respectively. However, because the counter can only handle integer inputs, this is rounded to 6553 and 0 ms respectively.\n\n\n\nMax/Min Frequency\nAccording to the STM reference manual, the TIM16 counter is able to go from 1 to 65536. Using these values and the TIM16 frequency as calculated above to be 10 MHz, the calculated max and min frequencies are as follows.\n\nMax Frequency\n\\[\nmax \\: frequency = {\\frac{10000000 {\\frac{ticks}{s}}}{1 \\: tick}} = 10 \\: MHz\n\\]\n\n\nMin Frequency\n\\[\nmax \\: frequency = {\\frac{10000000 {\\frac{ticks}{s}}}{655356 \\: ticks}} = 152.588 \\: Hz\n\\]\n\n\nDuration Conclusion\nBy calculation the theoretical max/min frequency are 10 MHz and 152.588 Hz respectively. However, because the counter can only handle integer inputs, this is rounded to 10 MHz and 153 Hz respectively.\n\n\n\nLM386 Circuit Design\nIn order to properly amplify the output PWM signal to the speaker, I passed the signal through a potentiometer and then into an LM386. The LM386 circuit I used was from the LM386 Datasheet for a gain of 20 (see Figure 1). The only thing I added to this circuit was a 0.1 μF bypass capacitor to deal with any noise in my power signal.\n\n\n\n\n\n\nFigure 1: LM386 Datasheet 20 gain circuit schematic."
  },
  {
    "objectID": "labs/lab4/lab4.html#technical-documentation",
    "href": "labs/lab4/lab4.html#technical-documentation",
    "title": "Lab 4 Report",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for the project can be found in the associated Github repository"
  },
  {
    "objectID": "labs/lab4/lab4.html#schematic",
    "href": "labs/lab4/lab4.html#schematic",
    "title": "Lab 4 Report",
    "section": "Schematic",
    "text": "Schematic\n\n\n\n\n\n\nFigure 2: Schematic of the layout including the STM and the LM386. The pins of the LM386 are labeled and pin 6 of the LM386 is moved to the left side of the LM386 for ease of circuit connections.\n\n\n\nFigure 2 shows the physical layout of the design. The choice of values for each component is described in the design and testing methodology. The PWM signal comes from PA6 out of the GPIOA port bank."
  },
  {
    "objectID": "labs/lab4/lab4.html#results-and-discussion",
    "href": "labs/lab4/lab4.html#results-and-discussion",
    "title": "Lab 4 Report",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nPicture of Circuit and Video of Chosen Composition (“Soda Pop” by the Saja Boys)\nThe working circuit is pictured below in Figure 3.\n\n\n\n\n\n\nFigure 3: Picture of the working circuit.\n\n\n\nI chose “Soda Pop” by the Saja Boys from the movie Kpop Demon Hunters as my extra song. Here is the circuit playing the tune."
  },
  {
    "objectID": "labs/lab4/lab4.html#conclusion",
    "href": "labs/lab4/lab4.html#conclusion",
    "title": "Lab 4 Report",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully plays Für Elise at the right tempo and with proper rests. Individual pitches are calculated to be accurate within 1% across the frequency range of 220-1000 Hz. The code uses #define macros for memory-mapped registers.The design incorporates a potentiometer and is able to play another song of my choice.\nOverall a success!"
  },
  {
    "objectID": "labs/lab4/lab4.html#ai-prototype-and-reflection",
    "href": "labs/lab4/lab4.html#ai-prototype-and-reflection",
    "title": "Lab 4 Report",
    "section": "AI Prototype and Reflection",
    "text": "AI Prototype and Reflection\n\nBest Timer Choice: TIM2\nThe Claude AI said that the best timer choice would be TIM2 because it has a 32-bit timer which allows PWM output mode, gives more flexibility for the prescaler, and has multiple channels that can be routed to the GPIO pins via alternate functions. However, the AI said alternatively TIM1 or TIM15/16 also work well just with a smaller counter.\nThis makes sense to me as the flexibility would be an important part to having a greater range of durations to be able to play as well as less concern with overflowing the counter.\n\n\nRelevant Formulae\nAccording to Claudem the output frequency is determined by:\nf_out = f_timer / ((PSC + 1) × (ARR + 1))\nClaude defines f_{out} as the timer clock frequency of typically 80 MHz.\nFor a 50% duty cycle PWM, Claude writes the equation as\nCCRx = ARR / 2\nBoth of the equations above are the equations I used to calculate my counter frequency and a 50% duty cycle.\n\n\nExample Calculations\nThe following is quoted from the Claude AI:\n\n\nClaude AI Example Calculations\n\nFor 220 Hz with 80 MHz timer clock:\nTarget count = 80,000,000 / 220 = 363,636 Choose PSC = 99 (divides by 100) ARR = 80,000,000 / (100 × 220) - 1 = 3,636 - 1 = 3,635 Actual frequency = 80,000,000 / (100 × 3,636) = 220.02 Hz\nFor 1 kHz:\nPSC = 79 (divides by 80) ARR = 80,000,000 / (80 × 1000) - 1 = 999 Actual frequency = 1,000 Hz exactly\n\nI actually really like how the AI calcualted the right ARR. I simply knew from debugging my program that the division rounds down and so I used that when calculating the target. However, it seems like the AI is changing PSC between the two frequencies whereas my program only uses one PSC to capture the full range from 220 Hz to 1kHz.\n\n\nKey Register to Configure\n\n1. RCC Registers - Enable Clocks\nRCC-&gt;APB1ENR1 |= RCC_APB1ENR1_TIM2EN;  // Enable TIM2 clock\n\nRCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOAEN;   // Enable GPIO port clock\n\nBecause I used TIM15/16 I enabled APB2ENR1 and AHB2ENR.\n\n\n2. GPIO Configuration - Set alternate function\nFor TIM2_CH1 on PA0 (example):\nGPIOA-&gt;MODER &= ~GPIO_MODER_MODE0;     // Clear mode bits\n\nGPIOA-&gt;MODER |= GPIO_MODER_MODE0_1;    // Set to alternate function\n\nGPIOA-&gt;AFR[0] |= (1 &lt;&lt; GPIO_AFRL_AFSEL0_Pos);  // AF1 for TIM2\n\nI used the pinMode function given to us in the tutorial GPIO header, however I did need to set AFR for PIN16 for my output PWM signal.\n\n\n3. TIM2 Registers\nTIM2-&gt;PSC = 99; // For 220 Hz example\n\nTIM2-&gt;CCR1 = 1818;  // 50% duty cycle (ARR/2)\n\nTIM2-&gt;CCMR1 |= (6 &lt;&lt; TIM_CCMR1_OC1M_Pos);  // PWM mode 1\n\nTIM2-&gt;CCMR1 |= TIM_CCMR1_OC1PE;            // Preload enable\n\nTIM2-&gt;CCER |= TIM_CCER_CC1E;  // Enable output on channel 1\n\nTIM2-&gt;CR1 |= TIM_CR1_ARPE;  // Auto-reload preload enable\n\nTIM2-&gt;CR1 |= TIM_CR1_CEN;   // Counter enable (start timer)\n\nTIM2-&gt;EGR |= TIM_EGR_UG;  // Generate update event to load registers\n\nI did use all of these but I also ended up needing to set BDTR as well for PWM output mode.\n\n\nGPIO Pin Mapping Options (TIM2)\nPA0 - TIM2_CH1 (AF1)\nPA1 - TIM2_CH2 (AF1)\nPA5 - TIM2_CH1 (AF1)\nPB3 - TIM2_CH2 (AF1)\nCheck your specific board’s pinout to ensure the pin is accessible on the nucleo headers.\nI used PA6 because that was the Channel 1 for TIM16.\n\n\nSummary Configuration Sequence\n\nEnable RCC clocks (timer + GPIO)\nConfigure GPIO pin for alternate function\nSet PSC and ARR for desired frequency\nSet CCRx for duty cycle\nConfigure PWM mode in CCMR register\nEnable output in CCER register\nEnable counter in CR1\n\nThese were the steps I used with the enable RCC clocks and configure GPIO pin in my main function whereas the rest of the steps were held in their own function in my TIMX.c file."
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab 5 Report",
    "section": "",
    "text": "I spent 20 hours on this lab."
  },
  {
    "objectID": "labs/lab5/lab5.html#lab-hours",
    "href": "labs/lab5/lab5.html#lab-hours",
    "title": "Lab 5 Report",
    "section": "",
    "text": "I spent 20 hours on this lab."
  },
  {
    "objectID": "labs/lab5/lab5.html#introduction",
    "href": "labs/lab5/lab5.html#introduction",
    "title": "Lab 5 Report",
    "section": "Introduction",
    "text": "Introduction\nLab 5 involved learning how to use interrupts to quickly and accurately sample inputs by calculating the velocity of a motor using quadrature encoders."
  },
  {
    "objectID": "labs/lab5/lab5.html#design-and-testing-methodology",
    "href": "labs/lab5/lab5.html#design-and-testing-methodology",
    "title": "Lab 5 Report",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\n\nComputing Velocity\nFor using a 12V 150RPM motor, the pulses per revolution (PPR) was 408 according to the motor’s datasheet (see Figure 1). In order to get the velocity in revolutions per second (RPS), a counter was used to find pulses per second (PPS). Because the lab uses quadrature encoder with an A signal and a B signal for the motor and the interrupt flag waves at the rising edge and falling edge of both A and B, the counter in my program counts how many flags were seen in a 1 second delay needs to divided by 4 in order to find the actual PPS:\n\n\n\n\n\n\nFigure 1: TS-25GA370H 12V 150 RPM motor datasheet.\n\n\n\n\\[\nPPS = \\frac{counter}{4}\n\\]\nTo get RPS, the PPS then needs to account for how many pulses are in one revolution:\n\\[\nRPS = \\frac{PPS}{PPR} = \\frac{PPS}{408}\n\\]\nUsing the above calculations, I derived the speed in revolutions per second. However, for direction this depends on the which clock is leading. The interrupt EXTI1 assumes input A is leading and thus if input A and B are not the same, that means this assumption is true, thus the clock is moving clockwise and the counter should be increased (CW is positive). If input A and B are the same, then the assumption is not true, thus the clock is moving counter-clockwise and the counter should be decreased (CCW is negative). The interrupt EXTI2 assumes input B is leading and uses the same logic except if the inputs are the same then the clock if moving CCW, and if the inputs are not the same then the clock is moving CW. Having both interrupts is necessary in order to check the rising and falling edges of BOTH A and B inputs.\n\n\nChecking Velocity at 12V\nSince the motor used is rated for 150 RPM at 12V, I can check that the measured and printed velocity is the same as the actual true velocity. If the motor is moving at 150 RPM this can be converted to RPS:\n\\[\nRPS = \\frac{RPM}{60} = \\frac{150}{60} = 2.5 \\: rev/s\n\\]\nThus, the measured velocity should be around 2.5 rev/s when the motor is powered at 12V.\n\n\nInterrupts versus Manual Polling\nWhile interrupts stop the main loop from continuing until the interrupt task is done, manual polling happens in parallel or while the main loop is running. This means manual polling misses edges while the delay is running. The pulses the polling misses can be calculated using the motor’s PPR. Using an oscilloscope on the quadrature encodings, I found the quadrature encoder signal was running at 1.86 kHz which is 1860 PPS. Using this I was able to find how many RPS we would miss in the manual polling.\n\\[\nRPS_{lost} = \\frac{PPS_{quadrature}}{PPR} = \\frac{1860}{408} = 4.559 \\: rev/s\n\\]\nThus, we would lose approximately 5 revolutions per second using manual polling. Because the interrupts capture every edge of the quadrature encoder and stops the main loop from running while the interrupt is handling the interrupt task, the interrupts provide the highest-resolution measurement of the velocity whereas the manual polling loses resolution."
  },
  {
    "objectID": "labs/lab5/lab5.html#technical-documentation",
    "href": "labs/lab5/lab5.html#technical-documentation",
    "title": "Lab 5 Report",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for the project can be found in the associated Github repository"
  },
  {
    "objectID": "labs/lab5/lab5.html#schematic",
    "href": "labs/lab5/lab5.html#schematic",
    "title": "Lab 5 Report",
    "section": "Schematic",
    "text": "Schematic\n\n\n\n\n\n\nFigure 2: Schematic of the layout including the STM and the motor. The motor is depicted simply as a block here.\n\n\n\nFigure 2 shows the physical layout of the design. The GPIOA pins PA1 and PA2 were chosen for their ability to handle the 5V output from the MCU into the motor."
  },
  {
    "objectID": "labs/lab5/lab5.html#flow-chart",
    "href": "labs/lab5/lab5.html#flow-chart",
    "title": "Lab 5 Report",
    "section": "Flow Chart",
    "text": "Flow Chart\n\n\n\n\n\n\nFigure 3: Flow chart of main function and two interrupt functions. Abstracted to only include high-level understandings.\n\n\n\nFigure 3 shows the flow of the program including the main function and the interrupt functions for the A and B signals of the quadrature encoder. ## Results and Discussion"
  },
  {
    "objectID": "labs/lab5/lab5.html#conclusion",
    "href": "labs/lab5/lab5.html#conclusion",
    "title": "Lab 5 Report",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully outputs the velocity with the correct direction with at least a 1 Hz update rate. The program measured the velocity to be 2.8 rev/s at 12V which is very close to our expected velocity of 2.5 rev/s. The program utilizes all edges of the quadrature encoders, does not miss any edges at high speeds, reports 0 when the fan is unmoving, and does not report 0 at low speeds (has high resolution).\nOverall a success!"
  },
  {
    "objectID": "labs/lab5/lab5.html#ai-prototype-and-reflection",
    "href": "labs/lab5/lab5.html#ai-prototype-and-reflection",
    "title": "Lab 5 Report",
    "section": "AI Prototype and Reflection",
    "text": "AI Prototype and Reflection\nThe Claude AI did not pass on the first run. The program included the header \"stm32l4xx_hal.h\" which was not recognized by Segger. I asked the AI to instead use &lt;stm32l432xx.h&gt;. This change did create a buildable solution. However, there was no code to show the velocity anywhere. So I prompted the AI to output the velocity using printf.\nThe AI actually gave me two methods: one for Hardware Encoder Mode that uses TIM2 encoder interface and no interrupts and another for Software Encoder Mode that uses the EXTI interrupts like I did. Another fun thing the AI did was also find the position not just the velocity. To keep things simple I asked just for velocity and to use Method 2.\n\n\nMethod 2: Software Encoder Mode\n\n/* Quadrature Encoder Interface for STM32L432KC\n * GPIO Interrupt Mode - Velocity Only\n * Direct register access without HAL\n */\n\n#include &lt;stm32l432xx.h&gt;\n#include &lt;stdio.h&gt;\n\n/* ============================================\n * PRINTF RETARGET FOR SWO/ITM (ST-Link)\n * ============================================ */\n\nint _write(int file, char *ptr, int len)\n{\n    for(int i = 0; i &lt; len; i++) {\n        ITM_SendChar((*ptr++));\n    }\n    return len;\n}\n\n/* ============================================\n * GPIO INTERRUPT MODE - VELOCITY CALCULATION\n * Software quadrature decoding using EXTI interrupts\n * Connect encoder to PA0 (Channel A) and PA1 (Channel B)\n * ============================================ */\n\n#define ENCODER_A_PIN 0\n#define ENCODER_B_PIN 1\n\nvolatile int32_t encoder_count = 0;\nvolatile int32_t encoder_velocity = 0;  // counts per second\nvolatile uint8_t last_state = 0;\n\nvoid Encoder_GPIO_Init(void)\n{\n    // Enable clocks for GPIOA and SYSCFG\n    RCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOAEN;\n    RCC-&gt;APB2ENR |= RCC_APB2ENR_SYSCFGEN;\n    \n    // Configure PA0 and PA1 as inputs\n    GPIOA-&gt;MODER &= ~(GPIO_MODER_MODE0 | GPIO_MODER_MODE1);\n    \n    // Enable pull-ups\n    GPIOA-&gt;PUPDR &= ~(GPIO_PUPDR_PUPD0 | GPIO_PUPDR_PUPD1);\n    GPIOA-&gt;PUPDR |= (GPIO_PUPDR_PUPD0_0 | GPIO_PUPDR_PUPD1_0);\n    \n    // Configure EXTI for PA0 and PA1\n    SYSCFG-&gt;EXTICR[0] &= ~(SYSCFG_EXTICR1_EXTI0 | SYSCFG_EXTICR1_EXTI1);\n    // EXTI0 and EXTI1 connected to PA0 and PA1 (value 0 = GPIOA)\n    \n    // Enable rising and falling edge triggers\n    EXTI-&gt;RTSR1 |= (EXTI_RTSR1_RT0 | EXTI_RTSR1_RT1);\n    EXTI-&gt;FTSR1 |= (EXTI_FTSR1_FT0 | EXTI_FTSR1_FT1);\n    \n    // Unmask interrupts\n    EXTI-&gt;IMR1 |= (EXTI_IMR1_IM0 | EXTI_IMR1_IM1);\n    \n    // Enable NVIC interrupts\n    NVIC_SetPriority(EXTI0_IRQn, 2);\n    NVIC_EnableIRQ(EXTI0_IRQn);\n    \n    NVIC_SetPriority(EXTI1_IRQn, 2);\n    NVIC_EnableIRQ(EXTI1_IRQn);\n    \n    // Read initial state\n    last_state = ((GPIOA-&gt;IDR & (1 &lt;&lt; ENCODER_A_PIN)) ? 2 : 0) | \n                 ((GPIOA-&gt;IDR & (1 &lt;&lt; ENCODER_B_PIN)) ? 1 : 0);\n}\n\nvoid Encoder_Process(void)\n{\n    uint8_t current_state = ((GPIOA-&gt;IDR & (1 &lt;&lt; ENCODER_A_PIN)) ? 2 : 0) | \n                            ((GPIOA-&gt;IDR & (1 &lt;&lt; ENCODER_B_PIN)) ? 1 : 0);\n    \n    // State transition table for quadrature decoding\n    int8_t direction = 0;\n    uint8_t transition = (last_state &lt;&lt; 2) | current_state;\n    \n    switch(transition) {\n        // Clockwise transitions\n        case 0b0001: case 0b0111: case 0b1110: case 0b1000:\n            direction = 1;\n            break;\n        // Counter-clockwise transitions\n        case 0b0010: case 0b1011: case 0b1101: case 0b0100:\n            direction = -1;\n            break;\n        // Invalid or no change\n        default:\n            direction = 0;\n            break;\n    }\n    \n    encoder_count += direction;\n    last_state = current_state;\n}\n\n// EXTI0 interrupt handler (Channel A on PA0)\nvoid EXTI0_IRQHandler(void)\n{\n    if(EXTI-&gt;PR1 & EXTI_PR1_PIF0) {\n        EXTI-&gt;PR1 = EXTI_PR1_PIF0;  // Clear pending bit\n        Encoder_Process();\n    }\n}\n\n// EXTI1 interrupt handler (Channel B on PA1)\nvoid EXTI1_IRQHandler(void)\n{\n    if(EXTI-&gt;PR1 & EXTI_PR1_PIF1) {\n        EXTI-&gt;PR1 = EXTI_PR1_PIF1;  // Clear pending bit\n        Encoder_Process();\n    }\n}\n\nvoid Encoder_CalculateVelocity(void)\n{\n    static int32_t last_count = 0;\n    int32_t current_count = encoder_count;\n    \n    // Calculate change in count (delta)\n    int32_t delta = current_count - last_count;\n    \n    // Velocity in counts per second (assuming 100ms sampling = 10 Hz)\n    encoder_velocity = delta * 10;\n    \n    last_count = current_count;\n}\n\nint32_t Encoder_GetVelocity(void)\n{\n    return encoder_velocity;\n}\n\n/* ============================================\n * SYSTICK TIMER FOR VELOCITY SAMPLING\n * ============================================ */\n\nvoid SysTick_Init(uint32_t ticks)\n{\n    SysTick-&gt;LOAD = ticks - 1;\n    SysTick-&gt;VAL = 0;\n    SysTick-&gt;CTRL = SysTick_CTRL_CLKSOURCE_Msk | \n                    SysTick_CTRL_TICKINT_Msk | \n                    SysTick_CTRL_ENABLE_Msk;\n}\n\nvoid SysTick_Handler(void)\n{\n    // Calculate velocity every 100ms\n    Encoder_CalculateVelocity();\n}\n\n/* ============================================\n * USAGE EXAMPLE\n * ============================================ */\n\n// Simple delay function (adjust based on your clock speed)\nvoid delay_ms(uint32_t ms)\n{\n    for(uint32_t i = 0; i &lt; ms * 4000; i++) {\n        __NOP();\n    }\n}\n\nint main(void)\n{\n    // Initialize GPIO interrupt mode encoder\n    Encoder_GPIO_Init();\n    \n    // Initialize SysTick for 100ms interrupts (assuming 4MHz clock)\n    // Adjust this value based on your actual system clock\n    SysTick_Init(400000);  // 4MHz / 10 = 400000 for 100ms\n    \n    while(1) {\n        // Read and print velocity only\n        int32_t velocity = Encoder_GetVelocity();  // counts per second\n        \n        printf(\"Velocity: %ld counts/sec\\r\\n\", velocity);\n        \n        delay_ms(100);\n    }\n}\n\n\nWhen I ran this in debug mode, the velocity was output as counts per second, but did not match the expected velocities. This is likely due to the integer nature of the variables in the Claude AI. The output would jump between 10 counts/sec to -10 counts/sec and sometimes 0 counts/sec in between. However, when the motor is stationary, the code does output 0 counts/sec correctly. Overall, the Claude AI was not very successful for this prompt."
  }
]