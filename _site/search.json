[
  {
    "objectID": "posts/week1-reflections.html",
    "href": "posts/week1-reflections.html",
    "title": "Week 1 Reflections",
    "section": "",
    "text": "This week I soldered all the components onto my development board, programmed LED0 to SW6 (S[1:0]) with an XOR gate, programmed LED1 to SW6 (S[3:2]) with an AND gate, programmed LED2 to blink at 2.4 Hz using the high frequency oscillator internal clock with a 24’bit counter, and programmed a 7-segment display to show a hexadecimal digit corresponding to SW6 (S[3:0])."
  },
  {
    "objectID": "posts/week1-reflections.html#summary",
    "href": "posts/week1-reflections.html#summary",
    "title": "Week 1 Reflections",
    "section": "",
    "text": "This week I soldered all the components onto my development board, programmed LED0 to SW6 (S[1:0]) with an XOR gate, programmed LED1 to SW6 (S[3:2]) with an AND gate, programmed LED2 to blink at 2.4 Hz using the high frequency oscillator internal clock with a 24’bit counter, and programmed a 7-segment display to show a hexadecimal digit corresponding to SW6 (S[3:0])."
  },
  {
    "objectID": "posts/week1-reflections.html#reflections-on-lab",
    "href": "posts/week1-reflections.html#reflections-on-lab",
    "title": "Week 1 Reflections",
    "section": "Reflections on Lab",
    "text": "Reflections on Lab\nThe lab was definitely difficult with learning how to use Radiant instead of Quartus Prime. I also found it tricky understanding how to program the blinking LED2 using the counter.\nI feel a lot more confident in understanding what is going on in a testbench program because before in E85 it seemed like somewhat of a black box to me.\nI’m still struggling with figuring out how to separate modules and writing testbenches for modules that don’t require a testvector file. I would like to continue strengthening my ability to write new modules and testbenches for those modules in a way that works in the overall top module. The trickiest module for this was trying to separate the clock divider for the blinking LED2 into another module. I ended up not doing a separate module because the code worked really well in the top module and I ran out of time.\nIf I have more time I would like to go back and retry making an led_blinker module that can have the HSOSC module outside of the led_blinker module and feed the internal clock int_osc into the blinking led module."
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1 Report",
    "section": "",
    "text": "I spent 24 hours working on this lab."
  },
  {
    "objectID": "labs/lab1/lab1.html#lab-hours",
    "href": "labs/lab1/lab1.html#lab-hours",
    "title": "Lab 1 Report",
    "section": "",
    "text": "I spent 24 hours working on this lab."
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction",
    "href": "labs/lab1/lab1.html#introduction",
    "title": "Lab 1 Report",
    "section": "Introduction",
    "text": "Introduction\nLab 1 dealt with setting up and testing the FPGA including soldering all parts of the board and writing SystemVerilog code to verify the LEDs and interface with a 7-segment display on a breadboard."
  },
  {
    "objectID": "labs/lab1/lab1.html#design-and-testing-methodology",
    "href": "labs/lab1/lab1.html#design-and-testing-methodology",
    "title": "Lab 1 Report",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\n\nBlinking LED2\nThe on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library was used to generate a clock signal at 24 MHz. Then, a counter was used to divide the high frequency clock signal to drive an external LED (LED2) such that it blinks at 2.4 Hz.\n\n\n\n\n\n\nFigure 1: The calculation for the counter to make LED2 blink at 2.4 Hz.\n\n\n\nThe calculation in Figure 1 derived that the counter needed to reach 5000000 before setting the LED HIGH in order to blink the LED at 2.4 Hz with a 50% duty cycle.\n\n\nResistor choice for 7-segment Display\n\n\n\n\n\n\nFigure 2: The calculation for the 7-segment current-limiting resistors using a V_f of 1.9V from the MAN4600 datasheet.\n\n\n\nThe calculation in Figure 2 derived 1kΩ as an appropriate resistor to provide ~1.9 mA to the LED segments."
  },
  {
    "objectID": "labs/lab1/lab1.html#technical-documentation",
    "href": "labs/lab1/lab1.html#technical-documentation",
    "title": "Lab 1 Report",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for the project can be found in the associated Github repository\n\nBlock Diagram\n\n\n\n\n\n\nFigure 3: Block diagram showing the top module and the two submodules HSOSC and sevensegment.\n\n\n\nThe block diagram in Figure 3 demonstrates the overall architecture of the design. The top-level module top includes two submodules: the high-speed oscillator block (HSOSC) and the 7-segment display module (sevensegment). The programming for the leds were placed in the top module."
  },
  {
    "objectID": "labs/lab1/lab1.html#schematic",
    "href": "labs/lab1/lab1.html#schematic",
    "title": "Lab 1 Report",
    "section": "Schematic",
    "text": "Schematic\n\n\n\n\n\n\nFigure 4: Schematic of the layout including the SW6 switch. The 7-segment display shares a common anode.\n\n\n\nFigure 4 shows the physical layout of the design. An internal 100 kΩ pullup resistor was used to ensure the active low reset pin for the switches was not floating. The output 7-segment diodes were connected using a 1kΩ current-limiting resistor to ensure the output current (~1.2 mA) did not exceed the maximum output current of the FPGA I/O pins. The figure also shows which pin number corresponds to which segment (i.e. a,b,c…) of the 7-segment display.\n\n\n\n\n\n\nFigure 5: Diagram of the letter assignment for the 7-segment display.\n\n\n\nFigure 5 depicts the assignment of letters to the output display. In the program, seg[0] corresponds to a, seg[1] to b, and so on."
  },
  {
    "objectID": "labs/lab1/lab1.html#results-and-discussion",
    "href": "labs/lab1/lab1.html#results-and-discussion",
    "title": "Lab 1 Report",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench Simulation\n\n\n\n\n\n\nFigure 6: Testbench simulation results for top module. Note the red comes from the blinking LED bit. The simulation shows outputs match expected outputs for all testvectors\n\n\n\nThe design met all intended design objectives. Figure 6 shows a screenshot of the QuestaSim simulation for the top module’s testbench tb_top. The simulated outputs of led and seg match their respective expected outputs.\n\n\n\n\n\n\nFigure 7: Testbench simulation results for sevensegment module. The simulation shows outputs match expected outputs for all testvectors\n\n\n\nFigure 7 shows a screenshot of the QuestaSim simulation for the sevensegment module’s testbench tb_sevseg. The simulated outputs of seg match the expected outputs.\nIf the design wanted to reuse the clock divider program, a separate module could be developed for the clock divider that takes the HSOSC int_osc output as an input."
  },
  {
    "objectID": "labs/lab1/lab1.html#conclusion",
    "href": "labs/lab1/lab1.html#conclusion",
    "title": "Lab 1 Report",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully blinked LED2 using the on-board high-speed oscillator, programmed LED1 and LED0 to the given truth table corresponding to s[3:2] and s[1:0] respectively, and displayed on the 7-segment display a single hexadecimal digit corresponding to the switches s[3:0] such that each digit is unique/distinguishable from the rest."
  },
  {
    "objectID": "labs/lab1/lab1.html#ai-prototype-and-reflection",
    "href": "labs/lab1/lab1.html#ai-prototype-and-reflection",
    "title": "Lab 1 Report",
    "section": "AI Prototype and Reflection",
    "text": "AI Prototype and Reflection\nThe first run with Claude AI produced a code very similar to the one I had written for the led_blinker by toggling the led under an always_ff statement with the counter. Some key differences was that the program used the SB_HFOSC module rather than the HSOSC which was new to me and was also unrecognized by Radiant giving a “instantiating unknown module” error.\nAfter feeding the error back into the LLM, the LLM fed back to declare the primitive with blackbox attribute which is also completely new to me. However parsing this still provided an error that CLKHF_DIV is not defined in this module. The instantiation of the SB_HFOSC module seemed to run into an error where the parameter in the module was not defined when later used in the module.\nAnother key difference and something new to me was that the program used localparam int to initialize a maximum counter and the width of the counter. The width of the counter used the code $clog2(COUNTER_MAX + 1) which I have never seen.\nIf I were to use the LLM again, I would like to tell the LLM what modules to use. The issue seemed to be with SB_HFOSC so feeding the LLM explicitly to use HSOSC could be quicker to getting towards a working code. Doing this actually changed the error to duplicate module name because the LLM program was trying to delcare the HSOSC primitive. Then feeding this error the LLM replied that the error is likely due to the HSOSC module already being available and it deleted the primitive declaration. After this deletion the code synthesized with no errors!\nI think the quality of the output is quite high. Each new section of code is commented with an overarching comment of the module’s function at the top. The only thing is that the LLM can get really stuck on executing the code one way and sometimes better quality code can be written by knowing multiple avenues of which to implement the code. So feeding the desired packages or modules can be really helpful in producing successful LLM code."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Hello Quarto\n\n\n\n\n\nWelcome to my Quarto portfolio\n\n\n\n\n\nAug 28, 2025\n\n\nErin Wang\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 1 Reflections\n\n\n\n\n\nBuilding my development board and programming in Verilog\n\n\n\n\n\nAug 28, 2025\n\n\nErin Wang\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Erin Wang is a senior engineering major at Harvey Mudd College. Her interests are in robotics and mechatronics specifically for building animatronics in theme parks. One of her personal projects is to build the robot from the REPO game with 3D printed material and off-the-shelf servo motors. The link to her Github can be found here.\nAfter college, she aims to apply for Masters programs robotics, electrical engineering, or mechanical engineering. When she is not working hard in her classes, music and food fill her life. She loves to dance and sing as well as compose music, and she is always willing to try a new food place."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2 Report",
    "section": "",
    "text": "I spent 20 hours on this lab."
  },
  {
    "objectID": "labs/lab2/lab2.html#lab-hours",
    "href": "labs/lab2/lab2.html#lab-hours",
    "title": "Lab 2 Report",
    "section": "",
    "text": "I spent 20 hours on this lab."
  },
  {
    "objectID": "labs/lab2/lab2.html#introduction",
    "href": "labs/lab2/lab2.html#introduction",
    "title": "Lab 2 Report",
    "section": "Introduction",
    "text": "Introduction\nLab 2 involved learning time multiplexing and application of PNP transistors to efficiently use the I/O on the FPGA by using one module and two 4 DIP switch inputs to control a dual 7-segment display on a breadboard. The lab also involved displaying the sum of the two inputs onto external LEDs."
  },
  {
    "objectID": "labs/lab2/lab2.html#design-and-testing-methodology",
    "href": "labs/lab2/lab2.html#design-and-testing-methodology",
    "title": "Lab 2 Report",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\n\nDual Display with one 7-Segment Module\nIn order to display two independent hexadecimal numbers on the dual 7-segment display using only one sevseg module, the trick was to send the same output to both digits but alternate between turning on the first digit and the second digit fast enough that the different digits are seen at the same time to our eyes (~60 Hz). To alternate between the two, the on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library was used to generate a clock signal at 24 MHz then a counter was used to divide the high frequency clock signal into a 60 Hz signal.\n\n\n\n\n\n\nFigure 1: The calculation for the counter to make the inputs and output powers alternate at 60 Hz.\n\n\n\nThe calculation in Figure 1 derived that the counter needed to reach 200000 before setting the multiplexer select HIGH in order switch between the two inputs and turning on the two outputs at 60 Hz. For example, if the first digit should read 1 and then second digit should read 5, then when clk is LOW, the program takes 1 as the input and sends 1 to both digits’ outputs. Then, the program turns only the first digit’s power on and turns the other digit’s power off. When clk is HIGH, the program takes 5 as the input and sends 5 to both digits’ outputs. Then the program turns the second digit’s power on and turns the first digit’s power off. This switch happens fast enough that the human eye sees both individual digits on the display.\n\n\nResistor choice for 7-segment Display\n\n\n\n\n\n\nFigure 2: The calculation for the 7-segment current-limiting resistors using a V_f of 1.9V from the MAN4600 datasheet.\n\n\n\nThe calculation in Figure 2 derived 1kΩ as an appropriate resistor to provide ~1.4 mA to the LED segments of the 7-segment display.\n\n\nResistor choice for external LEDs\n\n\n\n\n\n\nFigure 3: The calculation for the external LEDs current-limiting resistors using a V_f of 1.9V from the green LED datasheet.\n\n\n\nThe calculation in Figure 3 derived 1kΩ as an appropriate resistor to provide ~1.4 mA to the external LEDs. The calculation is the same as for the 7-segment display, however the cathodes of the LEDs are connected to ground rather than to a pin.\n\n\nResistor choice for transistors\n\n\n\n\n\n\nFigure 4: The calculation for the transistor current-limiting resistors using a V_f of 0.7V for the emitter diode such that the base voltage is 2.6V.\n\n\n\nThe calculation in Figure 4 derived 2.7kΩ as an appropriate resistor (stock-room available) to provide less than 1 mA to FPGA I/O pins."
  },
  {
    "objectID": "labs/lab2/lab2.html#technical-documentation",
    "href": "labs/lab2/lab2.html#technical-documentation",
    "title": "Lab 2 Report",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for the project can be found in the associated Github repository\n\nBlock Diagram\n\n\n\n\n\n\nFigure 5: Block diagram showing the top module and the three submodules HSOSC, mpx, and sevseg.\n\n\n\nThe block diagram in Figure 5 demonstrates the overall architecture of the design. The top-level module top includes three submodules: the high-speed oscillator block (HSOSC), the multiplexer to alternate at 60 Hz (mpx), and the 7-segment display module from Lab 1 (sevseg). The programming for the LED sum and the multiplexer logic using the select output of mpx were placed in the top module."
  },
  {
    "objectID": "labs/lab2/lab2.html#schematic",
    "href": "labs/lab2/lab2.html#schematic",
    "title": "Lab 2 Report",
    "section": "Schematic",
    "text": "Schematic\n\n\n\n\n\n\nFigure 6: Schematic of the layout not including the SW6 switch or the reset button (P43). The diodes of each digit of the 7-segment display share a common anode.\n\n\n\nFigure 6 shows the physical layout of the design. An internal 100 kΩ pullup resistor was used to ensure the active low reset pin for the switches was not floating. The output 7-segment diodes were connected using a 1kΩ current-limiting resistor to ensure the output current (~1.4 mA) did not exceed the maximum output current of the FPGA I/O pins. The external LED diodes (green) were connected using a 1kΩ current-limiting resistor to ensure the output current (~1.4 mA) did not exceed the maximum output current of the LEDs. The figure also shows which pin number of the dual display corresponds to which segment (i.e. A1,A2,B1, B2…) of the 7-segment display.\n\n\n\n\n\n\nFigure 7: Diagram of the letter assignment for the 7-segment display.\n\n\n\nFigure 7 depicts the assignment of letters to a digit of the output display. In the program, seg[0] corresponds to a, seg[1] to b, and so on."
  },
  {
    "objectID": "labs/lab2/lab2.html#results-and-discussion",
    "href": "labs/lab2/lab2.html#results-and-discussion",
    "title": "Lab 2 Report",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\nTestbench Simulation\n\ntop Module\n\n\n\n\n\n\nFigure 8: Testbench simulation results for top module showing the HSOSC toggling. The simulation shows outputs match expected outputs for all asserts\n\n\n\nThe design met all intended design objectives. Figure 8 shows a screenshot of the QuestaSim simulation for the top module’s testbench tb_top after approximately #10000 time units to show that the HSOSC toggles.\n\n\n\n\n\n\nFigure 9: Testbench simulation results for top module showing the outputs for the LED. The simulation shows the LED outputs match expected outputs for all asserts\n\n\n\nAs shown in Figure 9, the simulated outputs of led match the ledexpected output. Note that not all the tested inputs of led are shown in this image. The outputs of top: seg, trans0, and trans1 are not tested in this testbench because they rely on the mpx module which uses the HSOSC clock to provide the transistor output and switch input into sevseg. The outputs for seg are tested in the sevseg testbench while trans0 and trans1 and the switch input into sevseg are tested in the mpx testbench.\n\n\nsevseg Module\n\n\n\n\n\n\nFigure 10: Testbench simulation results for the sevseg module. The simulation shows outputs match expected outputs for all testvectors\n\n\n\nFigure 10 shows a screenshot of the QuestaSim simulation for the sevseg module’s testbench tb_sevseg. The simulated outputs of seg match the expected outputs.\n\n\nmpx Module\n\n\n\n\n\n\nFigure 11: Testbench simulation results for the mpx module for before the flip. The simulation shows outputs match expected outputs for all asserts\n\n\n\nFigure 11 shows a screenshot of the QuestaSim simulation for the mpx module’s testbench tb_mpx to test that the s, trans0, and trans1 output matches the expected outputs for before the alternation (aka flip) at counter = 200000. Because we are before the flip, s should be the same as the s0 input and trans0 and trans1 should be 0 and 1 respectively. The simulated outputs of mpx match the expected outputs for before the flip and the counter is counting up.\n\n\n\n\n\n\nFigure 12: Testbench simulation results for the mpx module for after the flip. The simulation shows outputs match expected outputs for all testvectors\n\n\n\nFigure 12 shows a screenshot of the QuestaSim simulation for the mpx module’s testbench tb_mpx to test that the s, trans0, and trans1 output matches the expected outputs for after the alternation (aka flip) that should occur when the counter reaches 200000. Because we are after the flip, s should be the same as the s1 input and trans0 and trans1 should be 1 and 0 respectively. The simulated outputs of mpx match the expected outputs for after the flip and the flip happens when the counter reaches 200000. The reset of the counter after count reaches 200000 is also visualized."
  },
  {
    "objectID": "labs/lab2/lab2.html#conclusion",
    "href": "labs/lab2/lab2.html#conclusion",
    "title": "Lab 2 Report",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully displayed two individual digits on the dual 7-segment display using only one sevseg module. The 5 LEDs also successfully display the sum of the two inputs. There is no bleeding between the digits or flickering and the 7-segment display does not dim depending on which numbers are displayed. The digits are also upright to the viewer."
  },
  {
    "objectID": "labs/lab2/lab2.html#ai-prototype-and-reflection",
    "href": "labs/lab2/lab2.html#ai-prototype-and-reflection",
    "title": "Lab 2 Report",
    "section": "AI Prototype and Reflection",
    "text": "AI Prototype and Reflection\n\nWithout Lab 1 Files Provided\nOff the bat I already recognized the Claude Ai put multiple modules in one file and the testbench module in another file. When trying to synthesize the code, there was an error in the testbench module. The testbench had two initial statements. The first initial statement housed the error of loop count limit exceeded forever never breaks. This is because the AI had setup the clock with the following code:\ninitial begin\n    clk = 0;\n    forever #5 clk = ~clk;\nend\nThis block of code is notably different from how I implement a clock. I use an always statement instead of initial to setup the clock.\nJust attempting to synthesize without including the testbench in implementation does work! Looking at theseven_seg_decoder module from the AI, the case statement looks like mine, accomodating for the common anode by having 1 as LOW and 0 as HIGH for the display. There is however no default case which could be a problem for debugging. The seven_seg_mux module uses the same clock divider setup as the provided example on the E155 website by using a counter and setting the multiplexer’s select to the last bit. What’s more strikingly different is that the input multiplexer code is an always_comb statement whereas I used the syntax for a multiplexer of select ? in1:in0. The AI also used an always_ff statement for the output demultiplexer with latches by turning the output to either all segments off or all segments on. However, we were told explicitly not to use latches and to use PNP transistors to control the anode power.\n\n\nWith Lab 1 Files Provided\nWith the Lab 1 files provided, the AI did not provide a testbench. The code was much shorter than without the Lab 1 files. The code does use HSOSC immediately which is different from the Lab 1 AI Prototype. For the time multiplexing, the AI created a clock divider to toggle at 1200 Hz. This seems a little high to me as a computer screen is around 60 Hz. Such high frequency could cause some bleeding between digits. The code for the multiplexer select is how I did the select in my code where the counter resets and the mux select switches to its opposite logic after a certain number of counts. The input multiplexer code was still an always_comb statement rather than the select ? in1:in0 format. The code then uses my sevensegment module to input the switch chosen from the always_comb statement and outputs the segments to turn on. The AI this time uses an always_comb for the output demultiplexer to use the multiplexer select from the clock divider to choose whether to make the first digit active and the second display off or vice versa. The default display is that both displays are off.\nThe code also provides a small section to use LEDs to check which display is active, check when the two inputs differ, and to blink at the frequency of the clock divider.\nOverall, I think both codes are very high quality although may be a little wordy considering mux logic can be much shorter than an always_comb statement. The code was interesting to compare as we didn’t specify to the AI to send an output to PNP transistors to control which digit was on and I think the prototype had a clever way of sending the output to the LED segments."
  }
]