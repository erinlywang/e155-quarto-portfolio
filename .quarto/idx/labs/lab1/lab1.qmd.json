{"title":"Lab 1 Report","markdown":{"yaml":{"title":"Lab 1 Report","author":"Erin Wang","date":"9/2/2025"},"headingText":"Lab Hours","containsRefs":false,"markdown":"\nI spent 24 hours working on this lab.\n\n## Introduction\nLab 1 dealt with setting up and testing the FPGA including soldering all parts of the board and writing SystemVerilog code to verify the LEDs and interface with a 7-segment display on a breadboard. \n\n## Design and Testing Methodology\n\n### Blinking LED2\nThe on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library was used to generate a clock signal at 24 MHz. Then, a counter was used to divide the high frequency clock signal to drive an external LED (LED2) such that it blinks at 2.4 Hz.\n\n![The calculation for the counter to make LED2 blink at 2.4 Hz.](images/lab1_ledcalc.jpg){#fig-ledcalc}\n\nThe calculation in @fig-ledcalc derived that the counter needed to reach 5000000 before setting the LED HIGH in order to blink the LED at 2.4 Hz with a 50% duty cycle.  \n\n### Resistor choice for 7-segment Display\n![The calculation for the 7-segment current-limiting resistors using a V_f of 2.1V from the MAN4600 datasheet.](images/lab1_sevsegcalc.jpg){#fig-sevsegcalc}\n\nThe calculation in @fig-sevsegcalc derived 1kΩ as an appropriate resistor to provide ~1.2 mA to the LED segments. \n\n## Technical Documentation\nThe source code for the project can be found in the associated [Github repository](https://github.com/erinlywang/e155-lab1)\n\n### Block Diagram\n![Block diagram showing the top module and the two submodules HSOSC and sevensegment.](images/lab1_block.jpg){#fig-block}\n\nThe block diagram in @fig-block demonstrates the overall architecture of the design. The top-level module `top` includes two submodules: the high-speed oscillator block (`HSOSC`) and the 7-segment display module (`sevensegment`). The programming for the leds were placed in the `top` module. \n\n## Schematic\n![Schematic of the layout including the SW6 switch. The 7-segment display shares a common anode.](images/lab1_schematic.jpg){#fig-schematic}\n\n@fig-schematic shows the physical layout of the design. An internal 100 kΩ pullup resistor was used to ensure the active low reset pin for the switches was not floating. The output 7-segment diodes were connected using a 1kΩ current-limiting resistor to ensure the output current (~1.2 mA) did not exceed the maximum output current of the FPGA I/O pins. The figure also shows which pin number corresponds to which segment (i.e. a,b,c...) of the 7-segment display.\n\n![Diagram of the letter assignment for the 7-segment display.](images/seven_seg_map.png){#fig-sevsegletters,}\n\n@fig-sevsegletters depicts the assignment of letters to the output display. In the program, seg[0] corresponds to a, seg[1] to b, and so on. \n\n## Results and Discussion\n\n### Testbench Simulation\n![Testbench simulation results for top module. Note the red comes from the blinking LED bit. The simulation shows outputs match expected outputs for all testvectors](images/lab1_toptest.png){#fig-tbtop}\n\nThe design met all intended design objectives. @fig-tbtop shows a screenshot of the QuestaSim simulation for the `top` module's testbench `tb_top`. The simulated outputs of `led` and `seg` match their respective expected outputs. \n\n![Testbench simulation results for sevensegment module. The simulation shows outputs match expected outputs for all testvectors](images/lab1_sevsegtest.png){#fig-tbsevseg}\n\n@fig-tbsevseg shows a screenshot of the QuestaSim simulation for the `sevensegment` module's testbench `tb_sevseg`. The simulated outputs of `seg` match the expected outputs. \n\nIf the design wanted to reuse the clock divider program, a separate module could be developed for the clock divider that takes the HSOSC `int_osc` output as an input.\n\n## Conclusion\n\nThe design successfully blinked LED2 using the on-board high-speed oscillator, programmed LED1 and LED0 to the given truth table corresponding to s[3:2] and s[1:0] respectively, and displayed on the 7-segment display a single hexadecimal digit corresponding to the switches s[3:0] such that each digit is unique/distinguishable from the rest.\n\n## AI Prototype and Reflection\n\nThe first run with Claude AI produced a code very similar to the one I had written for the led_blinker by toggling the led under an `always_ff` statement with the counter. Some key differences was that the program used the `SB_HFOSC` module rather than the `HSOSC` which was new to me and was also unrecognized by Radiant giving a \"instantiating unknown module\" error. \n\nAfter feeding the error back into the LLM, the LLM fed back to declare the primitive with blackbox attribute which is also completely new to me. However parsing this still provided an error that CLKHF_DIV is not defined in this module. The instantiation of the `SB_HFOSC` module seemed to run into an error where the parameter in the module was not defined when later used in the module. \n\nAnother key difference and something new to me was that the program used `localparam int` to initialize a maximum counter and the width of the counter. The width of the counter used the code `$clog2(COUNTER_MAX + 1)` which I have never seen.\n\nIf I were to use the LLM again, I would like to tell the LLM what modules to use. The issue seemed to be with `SB_HFOSC` so feeding the LLM explicitly to use `HSOSC` could be quicker to getting towards a working code. Doing this actually changed the error to duplicate module name because the LLM program was trying to delcare the HSOSC primitive. Then feeding this error the LLM replied that the error is likely due to the `HSOSC` module already being available and it deleted the primitive declaration. After this deletion the code synthesized with no errors! \n\nI think the quality of the output is quite high. Each new section of code is commented with an overarching comment of the module's function at the top. The only thing is that the LLM can get really stuck on executing the code one way and sometimes better quality code can be written by knowing multiple avenues of which to implement the code. So feeding the desired packages or modules can be really helpful in producing successful LLM code.\n","srcMarkdownNoYaml":"\n## Lab Hours\nI spent 24 hours working on this lab.\n\n## Introduction\nLab 1 dealt with setting up and testing the FPGA including soldering all parts of the board and writing SystemVerilog code to verify the LEDs and interface with a 7-segment display on a breadboard. \n\n## Design and Testing Methodology\n\n### Blinking LED2\nThe on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library was used to generate a clock signal at 24 MHz. Then, a counter was used to divide the high frequency clock signal to drive an external LED (LED2) such that it blinks at 2.4 Hz.\n\n![The calculation for the counter to make LED2 blink at 2.4 Hz.](images/lab1_ledcalc.jpg){#fig-ledcalc}\n\nThe calculation in @fig-ledcalc derived that the counter needed to reach 5000000 before setting the LED HIGH in order to blink the LED at 2.4 Hz with a 50% duty cycle.  \n\n### Resistor choice for 7-segment Display\n![The calculation for the 7-segment current-limiting resistors using a V_f of 2.1V from the MAN4600 datasheet.](images/lab1_sevsegcalc.jpg){#fig-sevsegcalc}\n\nThe calculation in @fig-sevsegcalc derived 1kΩ as an appropriate resistor to provide ~1.2 mA to the LED segments. \n\n## Technical Documentation\nThe source code for the project can be found in the associated [Github repository](https://github.com/erinlywang/e155-lab1)\n\n### Block Diagram\n![Block diagram showing the top module and the two submodules HSOSC and sevensegment.](images/lab1_block.jpg){#fig-block}\n\nThe block diagram in @fig-block demonstrates the overall architecture of the design. The top-level module `top` includes two submodules: the high-speed oscillator block (`HSOSC`) and the 7-segment display module (`sevensegment`). The programming for the leds were placed in the `top` module. \n\n## Schematic\n![Schematic of the layout including the SW6 switch. The 7-segment display shares a common anode.](images/lab1_schematic.jpg){#fig-schematic}\n\n@fig-schematic shows the physical layout of the design. An internal 100 kΩ pullup resistor was used to ensure the active low reset pin for the switches was not floating. The output 7-segment diodes were connected using a 1kΩ current-limiting resistor to ensure the output current (~1.2 mA) did not exceed the maximum output current of the FPGA I/O pins. The figure also shows which pin number corresponds to which segment (i.e. a,b,c...) of the 7-segment display.\n\n![Diagram of the letter assignment for the 7-segment display.](images/seven_seg_map.png){#fig-sevsegletters,}\n\n@fig-sevsegletters depicts the assignment of letters to the output display. In the program, seg[0] corresponds to a, seg[1] to b, and so on. \n\n## Results and Discussion\n\n### Testbench Simulation\n![Testbench simulation results for top module. Note the red comes from the blinking LED bit. The simulation shows outputs match expected outputs for all testvectors](images/lab1_toptest.png){#fig-tbtop}\n\nThe design met all intended design objectives. @fig-tbtop shows a screenshot of the QuestaSim simulation for the `top` module's testbench `tb_top`. The simulated outputs of `led` and `seg` match their respective expected outputs. \n\n![Testbench simulation results for sevensegment module. The simulation shows outputs match expected outputs for all testvectors](images/lab1_sevsegtest.png){#fig-tbsevseg}\n\n@fig-tbsevseg shows a screenshot of the QuestaSim simulation for the `sevensegment` module's testbench `tb_sevseg`. The simulated outputs of `seg` match the expected outputs. \n\nIf the design wanted to reuse the clock divider program, a separate module could be developed for the clock divider that takes the HSOSC `int_osc` output as an input.\n\n## Conclusion\n\nThe design successfully blinked LED2 using the on-board high-speed oscillator, programmed LED1 and LED0 to the given truth table corresponding to s[3:2] and s[1:0] respectively, and displayed on the 7-segment display a single hexadecimal digit corresponding to the switches s[3:0] such that each digit is unique/distinguishable from the rest.\n\n## AI Prototype and Reflection\n\nThe first run with Claude AI produced a code very similar to the one I had written for the led_blinker by toggling the led under an `always_ff` statement with the counter. Some key differences was that the program used the `SB_HFOSC` module rather than the `HSOSC` which was new to me and was also unrecognized by Radiant giving a \"instantiating unknown module\" error. \n\nAfter feeding the error back into the LLM, the LLM fed back to declare the primitive with blackbox attribute which is also completely new to me. However parsing this still provided an error that CLKHF_DIV is not defined in this module. The instantiation of the `SB_HFOSC` module seemed to run into an error where the parameter in the module was not defined when later used in the module. \n\nAnother key difference and something new to me was that the program used `localparam int` to initialize a maximum counter and the width of the counter. The width of the counter used the code `$clog2(COUNTER_MAX + 1)` which I have never seen.\n\nIf I were to use the LLM again, I would like to tell the LLM what modules to use. The issue seemed to be with `SB_HFOSC` so feeding the LLM explicitly to use `HSOSC` could be quicker to getting towards a working code. Doing this actually changed the error to duplicate module name because the LLM program was trying to delcare the HSOSC primitive. Then feeding this error the LLM replied that the error is likely due to the `HSOSC` module already being available and it deleted the primitive declaration. After this deletion the code synthesized with no errors! \n\nI think the quality of the output is quite high. Each new section of code is commented with an overarching comment of the module's function at the top. The only thing is that the LLM can get really stuck on executing the code one way and sometimes better quality code can be written by knowing multiple avenues of which to implement the code. So feeding the desired packages or modules can be really helpful in producing successful LLM code.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":true,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"lab1.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.40","theme":["cosmo","brand"],"math":{"method":"mathjax","options":{"autoNumber":"AMS"},"citations":true},"title":"Lab 1 Report","author":"Erin Wang","date":"9/2/2025"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}